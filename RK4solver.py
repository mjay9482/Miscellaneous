# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UFdfE4nPs5YUHV_7cqgi8nM_lR6GP4XB

#An overview of the comparison between the custom **RK4** method and the **solve_ivp** function.
"""

from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt

#Lorenz parameters
sigma = 10
rho  = 28
beta = 8/3

"""#This Function does a single 4th order Runge-kutta
where fun is the ode and dt is the timestep given t0 and y0 are the initial conditions
"""

def rk4singlestep(fun, dt, t0, y0):
  f1 = fun(t0,y0)
  f2 = fun(t0+dt/2 , y0+(dt/2)*f1)
  f3 = fun(t0+dt/2 , y0+(dt/2)*f2)
  f4 = fun(t0+dt/2 , y0+dt*f3)
  yout = y0 + (dt/6)*(f1+ 2*f2 +2*f3 +f4)
  return yout

"""# This Function defines the dynamical equations thta represents Lorenz System"""

def lorenz(t, y):
    dy = np.zeros(3)
    dy[0] = sigma * (y[1] - y[0])
    dy[1] = y[0] * (rho - y[2]) - y[1]
    dy[2] = y[0] * y[1] - beta * y[2]
    return dy

# Initialize the condition
y0 = [-8, 8, 27]

# Complete the trajectory
dt = 0.01
T = 10
num_time_pts = int(T / dt)
t = np.linspace(0, T, num_time_pts)

# Initialize the trajectory array
Y = np.zeros((3, num_time_pts))
Y[:, 0] = y0
yin = y0
# Simulate using custom RK4 method
for i in range(num_time_pts - 1):
    yout = rk4singlestep(lorenz, dt, t[i], yin)
    Y[:, i + 1] = yout
    yin = yout

# Plot the trajectory using the custom RK4 method
ax = plt.figure().add_subplot(projection='3d')
ax.plot(Y[0, :], Y[1, :], Y[2, :], 'b')

# Simulate using solve_ivp from SciPy
lorenz_solution = solve_ivp(lorenz, (0, T), y0, t_eval=t)
t = lorenz_solution.t
y = lorenz_solution.y.T
# Plot the trajectory using solve_ivp
ax.plot(y[:, 0], y[:, 1], y[:, 2], 'r')

# Show the 3D plot
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
ax.set_zlabel('Z-axis')
plt.show()